<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeFi TVL Growth Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e4e4e4;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 40px 0;
        }

        header h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        header p {
            color: #888;
            font-size: 1.1rem;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .timeframe-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        .timeframe-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .timeframe-btn.active {
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            font-weight: bold;
        }

        .section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section h2 {
            margin-bottom: 20px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section h2 .icon {
            font-size: 1.8rem;
        }

        .loading {
            text-align: center;
            padding: 60px;
            color: #888;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 16px 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        th {
            background: rgba(0, 0, 0, 0.3);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 0.5px;
            color: #00d4ff;
        }

        tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .rank {
            font-weight: bold;
            color: #7b2cbf;
            width: 50px;
        }

        .protocol-name {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .protocol-logo {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
        }

        .tvl {
            font-weight: 600;
        }

        .change {
            font-weight: bold;
            padding: 4px 10px;
            border-radius: 6px;
            display: inline-block;
        }

        .change.positive {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }

        .change.negative {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }

        .chains-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-width: 300px;
        }

        .chain-tag {
            background: rgba(123, 44, 191, 0.3);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .chain-tag.highlight {
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            color: #fff;
            font-weight: bold;
        }

        .error {
            text-align: center;
            padding: 40px;
            color: #ff4444;
        }

        .stats-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-card .value {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-card .label {
            color: #888;
            margin-top: 8px;
        }

        .table-container {
            overflow-x: auto;
        }

        .refresh-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            color: #fff;
            cursor: pointer;
            font-size: 1rem;
            margin-left: 20px;
        }

        .refresh-btn:hover {
            opacity: 0.9;
        }

        .refresh-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .last-updated {
            text-align: center;
            color: #666;
            font-size: 0.9rem;
            margin-top: 20px;
        }

        footer {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        footer a {
            color: #00d4ff;
            text-decoration: none;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8rem;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            th, td {
                padding: 12px 8px;
                font-size: 0.9rem;
            }

            .chains-list {
                max-width: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìà DeFi TVL Growth Tracker</h1>
            <p>Track protocols and chains with the highest TVL growth</p>
        </header>

        <div class="controls">
            <button class="timeframe-btn active" data-timeframe="1">24 Hours</button>
            <button class="timeframe-btn" data-timeframe="7">7 Days</button>
            <button class="timeframe-btn" data-timeframe="30">1 Month</button>
            <button class="timeframe-btn" data-timeframe="180">6 Months</button>
            <button class="refresh-btn" id="refreshBtn">üîÑ Refresh Data</button>
        </div>

        <div class="stats-row" id="statsRow">
            <div class="stat-card">
                <div class="value" id="totalProtocols">-</div>
                <div class="label">Protocols Tracked</div>
            </div>
            <div class="stat-card">
                <div class="value" id="totalChains">-</div>
                <div class="label">Chains Tracked</div>
            </div>
            <div class="stat-card">
                <div class="value" id="avgGrowth">-</div>
                <div class="label">Avg Protocol Growth</div>
            </div>
            <div class="stat-card">
                <div class="value" id="topGrowth">-</div>
                <div class="label">Top Protocol Growth</div>
            </div>
        </div>

        <div class="section">
            <h2><span class="icon">üèÜ</span> Top Growing Protocols (TVL ‚â• $1M)</h2>
            <div class="table-container" id="protocolsContainer">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading protocol data...</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2><span class="icon">‚õìÔ∏è</span> Top Growing Chains (TVL ‚â• $10M)</h2>
            <div class="table-container" id="chainsContainer">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading chain data...</p>
                </div>
            </div>
        </div>

        <p class="last-updated" id="lastUpdated"></p>

        <footer>
            <p>Data provided by <a href="https://defillama.com" target="_blank">DefiLlama API</a></p>
            <p style="margin-top: 10px;">Built with ‚ù§Ô∏è for the DeFi community</p>
        </footer>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            PROTOCOL_MIN_TVL: 1_000_000,  // $1M
            CHAIN_MIN_TVL: 10_000_000,     // $10M
            TOP_RESULTS: 50,
            CACHE_DURATION: 5 * 60 * 1000  // 5 minutes
        };

        // State
        let state = {
            protocols: [],
            chains: [],
            currentTimeframe: 1,
            lastFetch: null,
            isLoading: false
        };

        // API Functions
        const API = {
            baseUrl: 'https://api.llama.fi',

            async fetchProtocols() {
                const response = await fetch(`${this.baseUrl}/protocols`);
                if (!response.ok) throw new Error('Failed to fetch protocols');
                return response.json();
            },

            async fetchChains() {
                const response = await fetch(`${this.baseUrl}/v2/chains`);
                if (!response.ok) throw new Error('Failed to fetch chains');
                return response.json();
            },

            async fetchProtocolTvl(slug) {
                const response = await fetch(`${this.baseUrl}/protocol/${slug}`);
                if (!response.ok) throw new Error(`Failed to fetch protocol: ${slug}`);
                return response.json();
            },

            async fetchChainTvl(chain) {
                const response = await fetch(`${this.baseUrl}/v2/historicalChainTvl/${chain}`);
                if (!response.ok) throw new Error(`Failed to fetch chain: ${chain}`);
                return response.json();
            }
        };

        // Utility Functions
        function formatNumber(num) {
            if (num >= 1e9) return `$${(num / 1e9).toFixed(2)}B`;
            if (num >= 1e6) return `$${(num / 1e6).toFixed(2)}M`;
            if (num >= 1e3) return `$${(num / 1e3).toFixed(2)}K`;
            return `$${num.toFixed(2)}`;
        }

        function formatPercent(num) {
            if (num === null || num === undefined || isNaN(num)) return 'N/A';
            const sign = num >= 0 ? '+' : '';
            return `${sign}${num.toFixed(2)}%`;
        }

        function getTimeframeDate(days) {
            const date = new Date();
            date.setDate(date.getDate() - days);
            return Math.floor(date.getTime() / 1000);
        }

        function findClosestDataPoint(data, targetTimestamp) {
            if (!data || data.length === 0) return null;
            
            let closest = data[0];
            let minDiff = Math.abs(data[0].date - targetTimestamp);
            
            for (const point of data) {
                const diff = Math.abs(point.date - targetTimestamp);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = point;
                }
            }
            
            // Only return if within 2 days of target
            if (minDiff > 2 * 24 * 60 * 60) return null;
            return closest;
        }

        function calculateChange(currentTvl, historicalTvl) {
            if (!historicalTvl || historicalTvl === 0) return null;
            return ((currentTvl - historicalTvl) / historicalTvl) * 100;
        }

        // Data Processing
        async function processProtocols(protocols, timeframeDays) {
            const targetTimestamp = getTimeframeDate(timeframeDays);
            const results = [];
            
            // Filter protocols by minimum TVL first
            const eligibleProtocols = protocols.filter(p => p.tvl >= CONFIG.PROTOCOL_MIN_TVL);
            
            // Process in batches to avoid rate limiting
            const batchSize = 10;
            const batches = [];
            
            for (let i = 0; i < Math.min(eligibleProtocols.length, 200); i += batchSize) {
                batches.push(eligibleProtocols.slice(i, i + batchSize));
            }

            for (const batch of batches) {
                const batchResults = await Promise.all(
                    batch.map(async (protocol) => {
                        try {
                            const details = await API.fetchProtocolTvl(protocol.slug);
                            const historicalData = details.tvl || [];
                            const historicalPoint = findClosestDataPoint(historicalData, targetTimestamp);
                            
                            if (!historicalPoint) return null;
                            
                            const change = calculateChange(protocol.tvl, historicalPoint.totalLiquidityUSD);
                            
                            // Calculate per-chain changes
                            const chainChanges = {};
                            const chains = protocol.chains || [];
                            
                            if (details.chainTvls) {
                                for (const chain of chains) {
                                    const chainData = details.chainTvls[chain]?.tvl || [];
                                    const chainHistorical = findClosestDataPoint(chainData, targetTimestamp);
                                    const currentChainTvl = details.currentChainTvls?.[chain] || 0;
                                    
                                    if (chainHistorical && currentChainTvl > 0) {
                                        chainChanges[chain] = {
                                            change: calculateChange(currentChainTvl, chainHistorical.totalLiquidityUSD),
                                            currentTvl: currentChainTvl
                                        };
                                    }
                                }
                            }

                            // Find chain with highest growth
                            let topChain = null;
                            let topChainChange = -Infinity;
                            
                            for (const [chain, data] of Object.entries(chainChanges)) {
                                if (data.change !== null && data.change > topChainChange) {
                                    topChainChange = data.change;
                                    topChain = chain;
                                }
                            }

                            return {
                                name: protocol.name,
                                slug: protocol.slug,
                                logo: protocol.logo,
                                tvl: protocol.tvl,
                                chains: chains,
                                change: change,
                                topChain: topChain,
                                topChainChange: topChainChange !== -Infinity ? topChainChange : null,
                                chainChanges: chainChanges
                            };
                        } catch (error) {
                            console.error(`Error processing ${protocol.name}:`, error);
                            return null;
                        }
                    })
                );
                
                results.push(...batchResults.filter(r => r !== null && r.change !== null));
                
                // Small delay between batches
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Sort by change percentage (highest first)
            return results
                .sort((a, b) => b.change - a.change)
                .slice(0, CONFIG.TOP_RESULTS);
        }

        async function processChains(chains, timeframeDays) {
            const targetTimestamp = getTimeframeDate(timeframeDays);
            const results = [];
            
            // Filter chains by minimum TVL
            const eligibleChains = chains.filter(c => c.tvl >= CONFIG.CHAIN_MIN_TVL);
            
            // Process in batches
            const batchSize = 5;
            const batches = [];
            
            for (let i = 0; i < eligibleChains.length; i += batchSize) {
                batches.push(eligibleChains.slice(i, i + batchSize));
            }

            for (const batch of batches) {
                const batchResults = await Promise.all(
                    batch.map(async (chain) => {
                        try {
                            const historicalData = await API.fetchChainTvl(chain.name);
                            const historicalPoint = findClosestDataPoint(historicalData, targetTimestamp);
                            
                            if (!historicalPoint) return null;
                            
                            const change = calculateChange(chain.tvl, historicalPoint.tvl);
                            
                            return {
                                name: chain.name,
                                tvl: chain.tvl,
                                change: change,
                                tokenSymbol: chain.tokenSymbol
                            };
                        } catch (error) {
                            console.error(`Error processing chain ${chain.name}:`, error);
                            return null;
                        }
                    })
                );
                
                results.push(...batchResults.filter(r => r !== null && r.change !== null));
                
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            return results
                .sort((a, b) => b.change - a.change)
                .slice(0, CONFIG.TOP_RESULTS);
        }

        // UI Rendering
        function renderProtocolsTable(protocols) {
            if (protocols.length === 0) {
                return `<div class="error">No protocol data available for this timeframe</div>`;
            }

            const rows = protocols.map((protocol, index) => {
                const changeClass = protocol.change >= 0 ? 'positive' : 'negative';
                const chainsHtml = protocol.chains.slice(0, 5).map(chain => {
                    const isTop = chain === protocol.topChain;
                    return `<span class="chain-tag ${isTop ? 'highlight' : ''}">${chain}${isTop ? ' ‚≠ê' : ''}</span>`;
                }).join('');
                
                const moreChains = protocol.chains.length > 5 ? 
                    `<span class="chain-tag">+${protocol.chains.length - 5} more</span>` : '';

                return `
                    <tr>
                        <td class="rank">#${index + 1}</td>
                        <td>
                            <div class="protocol-name">
                                <img class="protocol-logo" src="${protocol.logo}" alt="${protocol.name}" 
                                     onerror="this.style.display='none'">
                                <span>${protocol.name}</span>
                            </div>
                        </td>
                        <td class="tvl">${formatNumber(protocol.tvl)}</td>
                        <td><span class="change ${changeClass}">${formatPercent(protocol.change)}</span></td>
                        <td>
                            <div class="chains-list">
                                ${chainsHtml}
                                ${moreChains}
                            </div>
                        </td>
                        <td>
                            ${protocol.topChain ? 
                                `<strong>${protocol.topChain}</strong><br>
                                 <span class="change ${protocol.topChainChange >= 0 ? 'positive' : 'negative'}">
                                    ${formatPercent(protocol.topChainChange)}
                                 </span>` 
                                : 'N/A'}
                        </td>
                    </tr>
                `;
            }).join('');

            return `
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Protocol</th>
                            <th>Current TVL</th>
                            <th>TVL Change</th>
                            <th>Chains</th>
                            <th>Top Growing Chain</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
            `;
        }

        function renderChainsTable(chains) {
            if (chains.length === 0) {
                return `<div class="error">No chain data available for this timeframe</div>`;
            }

            const rows = chains.map((chain, index) => {
                const changeClass = chain.change >= 0 ? 'positive' : 'negative';
                
                return `
                    <tr>
                        <td class="rank">#${index + 1}</td>
                        <td><strong>${chain.name}</strong></td>
                        <td class="tvl">${formatNumber(chain.tvl)}</td>
                        <td><span class="change ${changeClass}">${formatPercent(chain.change)}</span></td>
                        <td>${chain.tokenSymbol || '-'}</td>
                    </tr>
                `;
            }).join('');

            return `
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Chain</th>
                            <th>Current TVL</th>
                            <th>TVL Change</th>
                            <th>Native Token</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
            `;
        }

        function updateStats(protocols, chains) {
            document.getElementById('totalProtocols').textContent = protocols.length;
            document.getElementById('totalChains').textContent = chains.length;
            
            if (protocols.length > 0) {
                const avgGrowth = protocols.reduce((sum, p) => sum + p.change, 0) / protocols.length;
                document.getElementById('avgGrowth').textContent = formatPercent(avgGrowth);
                document.getElementById('topGrowth').textContent = formatPercent(protocols[0].change);
            }
        }

        function showLoading(container) {
            container.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading data...</p>
                </div>
            `;
        }

        function showError(container, message) {
            container.innerHTML = `<div class="error">${message}</div>`;
        }

        // Main Functions
        async function fetchAllData() {
            if (state.isLoading) return;
            
            state.isLoading = true;
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.disabled = true;
            refreshBtn.textContent = '‚è≥ Loading...';

            const protocolsContainer = document.getElementById('protocolsContainer');
            const chainsContainer = document.getElementById('chainsContainer');

            showLoading(protocolsContainer);
            showLoading(chainsContainer);

            try {
                // Fetch base data
                const [protocols, chains] = await Promise.all([
                    API.fetchProtocols(),
                    API.fetchChains()
                ]);

                state.protocols = protocols;
                state.chains = chains;
                state.lastFetch = new Date();

                // Process and render
                await updateDisplay();

            } catch (error) {
                console.error('Error fetching data:', error);
                showError(protocolsContainer, `Error loading data: ${error.message}`);
                showError(chainsContainer, `Error loading data: ${error.message}`);
            } finally {
                state.isLoading = false;
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'üîÑ Refresh Data';
            }
        }

        async function updateDisplay() {
            const protocolsContainer = document.getElementById('protocolsContainer');
            const chainsContainer = document.getElementById('chainsContainer');

            showLoading(protocolsContainer);
            showLoading(chainsContainer);

            try {
                const [processedProtocols, processedChains] = await Promise.all([
                    processProtocols(state.protocols, state.currentTimeframe),
                    processChains(state.chains, state.currentTimeframe)
                ]);

                protocolsContainer.innerHTML = renderProtocolsTable(processedProtocols);
                chainsContainer.innerHTML = renderChainsTable(processedChains);
                
                updateStats(processedProtocols, processedChains);
                
                document.getElementById('lastUpdated').textContent = 
                    `Last updated: ${new Date().toLocaleString()}`;

            } catch (error) {
                console.error('Error processing data:', error);
                showError(protocolsContainer, `Error processing data: ${error.message}`);
                showError(chainsContainer, `Error processing data: ${error.message}`);
            }
        }

        // Event Listeners
        document.querySelectorAll('.timeframe-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                // Update active button
                document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Update timeframe and refresh display
                state.currentTimeframe = parseInt(btn.dataset.timeframe);
                
                if (state.protocols.length > 0) {
                    await updateDisplay();
                } else {
                    await fetchAllData();
                }
            });
        });

        document.getElementById('refreshBtn').addEventListener('click', fetchAllData);

        // Initial load
        fetchAllData();
    </script>
</body>
</html>